---
phase: 05-msupload-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/Hooks/UploadHooks.php
  - includes/Hooks/MsUploadHooks.php
  - extension.json
  - i18n/en.json
autonomous: true

must_haves:
  truths:
    - "API/bot uploads without wpFilePermLevel succeed using namespace/global default instead of being rejected"
    - "MsUpload bridge JS module is loaded only when MsUpload extension is installed"
    - "JS config vars wgFilePermLevels and wgFilePermMsUploadDefault are available on edit pages when MsUpload is present"
    - "ext.FilePermissions.msupload module is registered in extension.json with correct dependencies and messages"
    - "Nothing changes on pages where MsUpload is not installed (silent no-op)"
  artifacts:
    - path: "includes/Hooks/UploadHooks.php"
      provides: "Tolerant UploadVerifyUpload that applies default when wpFilePermLevel is absent"
      contains: "resolveDefaultLevel"
    - path: "includes/Hooks/MsUploadHooks.php"
      provides: "EditPage::showEditForm:initial hook handler for conditional bridge module loading"
      contains: "ExtensionRegistry"
    - path: "extension.json"
      provides: "MsUpload hook handler registration and ext.FilePermissions.msupload module definition"
      contains: "ext.FilePermissions.msupload"
    - path: "i18n/en.json"
      provides: "MsUpload bridge i18n messages"
      contains: "filepermissions-msupload-label"
  key_links:
    - from: "includes/Hooks/MsUploadHooks.php"
      to: "extension.json"
      via: "HookHandlers registration"
      pattern: "msupload"
    - from: "includes/Hooks/MsUploadHooks.php"
      to: "includes/Config.php"
      via: "Config::getLevels and Config::resolveDefaultLevel"
      pattern: "Config::getLevels|Config::resolveDefaultLevel"
    - from: "includes/Hooks/UploadHooks.php"
      to: "includes/Config.php"
      via: "Config::resolveDefaultLevel for default fallback"
      pattern: "resolveDefaultLevel"
---

<objective>
Fix the critical UploadVerifyUpload bug that blocks API uploads without wpFilePermLevel, create the MsUpload hook handler for conditional bridge module loading, register the new ResourceLoader module, and add i18n messages.

Purpose: Server-side foundation for MsUpload integration. The UploadVerifyUpload fix unblocks ALL non-form uploads (bots, API, MsUpload). The hook handler ensures the bridge JS only loads when MsUpload is present. Module registration makes the JS/CSS available to ResourceLoader.

Output: Modified UploadHooks.php, new MsUploadHooks.php, updated extension.json and i18n/en.json
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-msupload-integration/05-RESEARCH.md
@.planning/phases/05-msupload-integration/05-CONTEXT.md
@includes/Hooks/UploadHooks.php
@includes/Hooks/DisplayHooks.php
@includes/Config.php
@extension.json
@i18n/en.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix UploadVerifyUpload to apply default when wpFilePermLevel is absent</name>
  <files>includes/Hooks/UploadHooks.php</files>
  <action>
Modify `onUploadVerifyUpload` in UploadHooks.php to be tolerant of missing `wpFilePermLevel` parameter. Currently lines 95-100 reject uploads with null/empty wpFilePermLevel. This blocks ALL API uploads (bots, MsUpload before bridge loads, other extensions).

The fix:
1. When `$level` is null or empty, resolve a default using `Config::resolveDefaultLevel()` with the upload's target namespace (NS_FILE = 6).
2. If a default is resolved, allow the upload to proceed (return true). The `onUploadComplete` handler will use the same resolution logic to store the default.
3. If NO default is configured (resolveDefaultLevel returns null), ONLY reject the upload if it came from Special:Upload (where the user had a dropdown to choose). For API uploads, allow with no permission level (grandfathered behavior — the file will have no level, treated as unrestricted per decision [01-02]).

Detection of Special:Upload context: Check if the request has `wpUploadFile` or `wpUploadFileURL` parameters (these are HTMLForm fields specific to Special:Upload). If present, this is a form submission and mandatory selection applies. If absent, this is an API upload and the default/fallback applies.

Also update `onUploadComplete` to apply the resolved default when `wpFilePermLevel` is absent. Currently lines 131-135 silently skip storage when level is null/empty. Change this to:
1. Read `wpFilePermLevel` from request.
2. If null/empty, call `Config::resolveDefaultLevel( NS_FILE )` to get the default.
3. If still null (no default configured), return true (no level stored — grandfathered).
4. If a valid level is resolved, proceed to store it.

Do NOT change the validation-callback method `validatePermissionLevel` — that is only for HTMLForm and works correctly.

Add `use FilePermissions\Config;` if not already imported (it already is — verify).
  </action>
  <verify>
Read the modified file and verify:
1. `onUploadVerifyUpload`: When wpFilePermLevel is null and request has wpUploadFile, error is returned (Special:Upload path).
2. `onUploadVerifyUpload`: When wpFilePermLevel is null and request does NOT have wpUploadFile, returns true (API path).
3. `onUploadVerifyUpload`: When wpFilePermLevel is present and valid, returns true (unchanged behavior).
4. `onUploadVerifyUpload`: When wpFilePermLevel is present and invalid, returns error (unchanged behavior).
5. `onUploadComplete`: When wpFilePermLevel is null, resolves default via Config::resolveDefaultLevel and stores if non-null.
6. `onUploadComplete`: When wpFilePermLevel is present and valid, stores it (unchanged behavior).
  </verify>
  <done>
API uploads without wpFilePermLevel parameter succeed (not rejected). Special:Upload form submissions still require explicit selection. Upload completion stores the resolved default level when wpFilePermLevel is absent.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MsUploadHooks handler, register module, add i18n messages</name>
  <files>
includes/Hooks/MsUploadHooks.php
extension.json
i18n/en.json
  </files>
  <action>
**Step 1: Create includes/Hooks/MsUploadHooks.php**

Create a new hook handler class that implements the `EditPage::showEditForm:initial` hook. This matches the hook MsUpload itself uses to load its module.

```php
namespace FilePermissions\Hooks;

use FilePermissions\Config;
use MediaWiki\EditPage\EditPage;
use MediaWiki\Output\OutputPage;
use MediaWiki\Registration\ExtensionRegistry;
```

The class does NOT need PermissionService (no PageProps access needed here — only Config for levels and defaults).

Method: `onEditPageShowEditFormInitial( EditPage $editPage, OutputPage $output ): void`

Implementation:
1. Check `ExtensionRegistry::getInstance()->isLoaded( 'MsUpload' )` — if false, return immediately (silent no-op).
2. Get the page's namespace: `$output->getTitle()->getNamespace()`.
3. Call `$output->addModules( [ 'ext.FilePermissions.msupload' ] )`.
4. Call `$output->addJsConfigVars( [ 'wgFilePermLevels' => Config::getLevels(), 'wgFilePermMsUploadDefault' => Config::resolveDefaultLevel( $ns ) ] )`.

The hook name in MW 1.44 is `EditPage::showEditForm:initial`. The handler interface is `MediaWiki\EditPage\Hook\EditPageShowEditFormInitialHook`. Verify this interface exists in MW 1.44. The method signature is `onEditPage__showEditForm_initial( EditPage $editPage, OutputPage $output )` (note the double underscore — MW converts `:` to `__` and `.` to `_` in hook method names).

NOTE: The class should NOT have constructor services since it only needs static Config methods, but MW hook handler wiring requires a class entry in HookHandlers. Use an empty services array.

**Step 2: Update extension.json**

Add to `HookHandlers`:
```json
"msupload": {
    "class": "FilePermissions\\Hooks\\MsUploadHooks"
}
```
No services needed (Config is static).

Add to `Hooks`:
```json
"EditPage::showEditForm:initial": "msupload"
```

Add to `ResourceModules`:
```json
"ext.FilePermissions.msupload": {
    "localBasePath": "modules",
    "remoteExtPath": "FilePermissions/modules",
    "packageFiles": [
        "ext.FilePermissions.msupload.js"
    ],
    "styles": [
        "ext.FilePermissions.msupload.css"
    ],
    "dependencies": [
        "mediawiki.api"
    ],
    "messages": [
        "filepermissions-msupload-label",
        "filepermissions-msupload-error-nolevels",
        "filepermissions-msupload-error-save"
    ]
}
```

NOTE: `ext.MsUpload` is deliberately NOT a dependency. The module is only loaded server-side when MsUpload is installed. Do NOT add `oojs-ui-core` — the dropdown uses plain HTML select per research recommendation (MsUpload's UI is plain DOM, not OOUI).

**Step 3: Update i18n/en.json**

Add these messages:
- `"filepermissions-msupload-label"`: `"Permission level:"`
- `"filepermissions-msupload-error-nolevels"`: `"Error: Permission levels could not be loaded."`
- `"filepermissions-msupload-error-save"`: `"Warning: File uploaded but permission level may not have been saved for \"$1\". Check the file page."`

The error-save message uses $1 for the filename so the user knows which file had the issue.
  </action>
  <verify>
1. Read includes/Hooks/MsUploadHooks.php and verify it checks ExtensionRegistry::isLoaded('MsUpload') before adding modules/config vars.
2. Read extension.json and verify: (a) "msupload" HookHandler entry exists with correct class, (b) "EditPage::showEditForm:initial" hook is registered to "msupload", (c) "ext.FilePermissions.msupload" ResourceModule is defined with packageFiles, styles, dependencies, messages.
3. Read i18n/en.json and verify all three new messages exist.
4. Run `php /home/daharoni/dev/FilePermissions/maintenance/run.php checkComposerLockUpToDate` or equivalent lint check if available. If not, verify PHP syntax with `php -l includes/Hooks/MsUploadHooks.php`.
  </verify>
  <done>
MsUploadHooks.php created with EditPage::showEditForm:initial handler that conditionally loads ext.FilePermissions.msupload module and injects JS config vars. extension.json registers the handler, hook binding, and ResourceLoader module. i18n messages added for dropdown label and error states.
  </done>
</task>

</tasks>

<verification>
1. PHP syntax check: `php -l includes/Hooks/UploadHooks.php && php -l includes/Hooks/MsUploadHooks.php`
2. extension.json is valid JSON: `python3 -c "import json; json.load(open('extension.json'))"`
3. i18n/en.json is valid JSON: `python3 -c "import json; json.load(open('i18n/en.json'))"`
4. No duplicate keys in extension.json HookHandlers, Hooks, or ResourceModules
5. MsUploadHooks uses ExtensionRegistry for detection (not mw.loader or DOM checks)
6. UploadVerifyUpload no longer rejects uploads missing wpFilePermLevel in API context
</verification>

<success_criteria>
- UploadVerifyUpload tolerates missing wpFilePermLevel for API uploads (applies namespace/global default)
- Special:Upload form submissions still require explicit level selection
- MsUploadHooks.php exists and conditionally loads bridge module when MsUpload is installed
- ext.FilePermissions.msupload module registered in extension.json (no hard dependency on ext.MsUpload)
- Three new i18n messages added
- All PHP files pass syntax check
- All JSON files are valid
</success_criteria>

<output>
After completion, create `.planning/phases/05-msupload-integration/05-01-SUMMARY.md`
</output>
