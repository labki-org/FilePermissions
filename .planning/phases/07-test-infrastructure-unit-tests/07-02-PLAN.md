---
phase: 07-test-infrastructure-unit-tests
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - tests/phpunit/unit/PermissionServiceTest.php
autonomous: true

must_haves:
  truths:
    - "PermissionService grant matching correctly allows users whose group is granted the requested level"
    - "PermissionService grant matching correctly denies users whose group is NOT granted the requested level"
    - "PermissionService wildcard grant ('*') gives access to all levels"
    - "PermissionService fail-closed: invalid config flag causes canUserAccessLevel to return false"
    - "PermissionService default level assignment: files without explicit level use namespace or global default"
    - "PermissionService null level (no level set, no default) treats file as unrestricted (backward compat)"
    - "PermissionService unknown/missing files (page ID 0, wrong namespace) return null level"
    - "Each test creates a fresh PermissionService instance (no cache poisoning)"
  artifacts:
    - path: "tests/phpunit/unit/PermissionServiceTest.php"
      provides: "Unit tests for PermissionService covering UNIT-04, UNIT-05, UNIT-06"
      min_lines: 200
  key_links:
    - from: "tests/phpunit/unit/PermissionServiceTest.php"
      to: "includes/PermissionService.php"
      via: "constructor injection with mocked IConnectionProvider and UserGroupManager"
      pattern: "PermissionService"
    - from: "tests/phpunit/unit/PermissionServiceTest.php"
      to: "includes/Config.php"
      via: "$GLOBALS manipulation for Config static methods"
      pattern: "wgFilePermGroupGrants"
---

<objective>
Implement exhaustive unit tests for the PermissionService class using mocked dependencies (no database, no real services).

Purpose: Proves that permission grant matching, denial, default level assignment, and unknown/missing file handling all work correctly at the logic level (UNIT-04, UNIT-05, UNIT-06). Uses mocked IConnectionProvider and UserGroupManager to isolate pure permission logic from database and MW services.

Output: tests/phpunit/unit/PermissionServiceTest.php with comprehensive test coverage for all PermissionService public methods.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@includes/PermissionService.php
@includes/Config.php
@extension.json
@.planning/phases/07-test-infrastructure-unit-tests/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PermissionService unit tests with mocked dependencies</name>
  <files>tests/phpunit/unit/PermissionServiceTest.php</files>
  <action>
Create tests/phpunit/unit/PermissionServiceTest.php that extends MediaWikiUnitTestCase.

**Namespace:** `FilePermissions\Tests\Unit`

**Test philosophy:** This extension protects files and data. When in doubt, lean toward MORE exhaustive testing. Fail-closed behavior should be the most visibly tested property.

**Critical pitfall — cache poisoning:** Create a FRESH PermissionService instance per test method. The private `$levelCache` array persists on the instance. Never reuse a service instance across tests. Use a helper method like `createService($dbProvider, $userGroupManager)` that constructs a new instance each time.

**Mocking strategy:**

1. **IConnectionProvider** — Mock to return a mock IDatabase (replica or primary). For unit tests of canUserAccessLevel and canUserAccessFile, the DB methods may not even be called (when testing access logic only). For getLevel/getEffectiveLevel tests that exercise the DB path, mock the SelectQueryBuilder chain:
   - `$dbr->newSelectQueryBuilder()` returns a mock builder
   - Builder methods (`select`, `from`, `where`, `caller`) return `$this` (fluent)
   - `fetchRow()` returns either `false` (no row) or an object with `fpl_level` property

2. **UserGroupManager** — Mock `getUserEffectiveGroups(UserIdentity)` to return specific group arrays per test case.

3. **Title** — Mock with:
   - `getNamespace()` returning NS_FILE (6) or other namespace
   - `getArticleID()` returning a page ID (positive int) or 0 (nonexistent page)

4. **UserIdentity** — Mock interface, no methods needed beyond what UserGroupManager receives.

5. **Config globals** — Set `$GLOBALS['wgFilePermGroupGrants']`, `$GLOBALS['wgFilePermLevels']`, etc. directly. Reset all 5 in tearDown (same pattern as ConfigTest).

**Required test coverage:**

UNIT-04 — Permission checks with mocked DB provider:
- canUserAccessLevel: user in group with matching level grant → true
- canUserAccessLevel: user in group WITHOUT matching level grant → false
- canUserAccessLevel: user in group with wildcard '*' grant → true for any level
- canUserAccessLevel: user in multiple groups, one grants access → true
- canUserAccessLevel: user in multiple groups, none grants access → false
- canUserAccessLevel: user with no groups → false
- canUserAccessLevel: group exists in grants but has empty levels array → false
- canUserAccessLevel: user group not present in grants config at all → false
- canUserAccessLevel: fail-closed when wgFilePermInvalidConfig is true → false regardless of grants
- canUserAccessFile: file with explicit level, user has access → true
- canUserAccessFile: file with explicit level, user denied → false
- getLevel: returns level from DB for valid NS_FILE title with existing page
- getLevel: returns null for non-NS_FILE title
- getLevel: returns null for NS_FILE title with page ID 0 (nonexistent)
- getLevel: returns null when DB row not found (no level set)
- getLevel: caches result (second call does NOT query DB again)

UNIT-05 — Default level assignment:
- getEffectiveLevel: returns explicit level when set in DB
- getEffectiveLevel: returns namespace default when no explicit level and namespace default configured
- getEffectiveLevel: returns global default when no explicit level and no namespace default
- getEffectiveLevel: returns null when no explicit level, no namespace default, no global default
- canUserAccessFile with default level: user granted default level → true
- canUserAccessFile with default level: user NOT granted default level → false

UNIT-06 — Unknown/missing files:
- getLevel: nonexistent page (articleID = 0) returns null
- getLevel: wrong namespace (not NS_FILE) returns null
- canUserAccessFile: file with no level and no default → true (unrestricted/grandfathered)
- canUserAccessFile: file with no level but default applies and user lacks access → false
- getEffectiveLevel: nonexistent file returns default level (not null, if default configured)

**Naming convention:** Descriptive method names making security guarantees obvious. Examples:
- `testCanUserAccessLevelReturnsFalseWhenConfigInvalid_FailClosed`
- `testCanUserAccessFileReturnsTrueWhenNoLevelSet_UnrestrictedFile`
- `testGetLevelReturnsNullForNonexistentPage`

Use `@covers` annotations pointing to specific PermissionService methods.
Use `@dataProvider` (static methods) where it reduces duplication.
  </action>
  <verify>
1. File exists at tests/phpunit/unit/PermissionServiceTest.php
2. Class extends MediaWikiUnitTestCase
3. Namespace is FilePermissions\Tests\Unit
4. Every test creates a fresh PermissionService instance (grep for "new PermissionService" — should appear in helper method, called per test)
5. Mocks: IConnectionProvider, UserGroupManager, Title, UserIdentity are mocked (no real MW services)
6. Test count: at minimum 25 test scenarios covering UNIT-04, UNIT-05, UNIT-06
7. All PermissionService public methods have @covers annotations
8. tearDown resets all 5 $GLOBALS
9. Fail-closed test explicitly verifies canUserAccessLevel returns false when wgFilePermInvalidConfig=true
10. Unrestricted file test explicitly verifies canUserAccessFile returns true when no level applies
  </verify>
  <done>PermissionServiceTest.php covers all UNIT-04 (grant matching, deny, allow with mocked deps), UNIT-05 (default level assignment), and UNIT-06 (unknown/missing files) requirements. Fresh service instances per test prevent cache poisoning. All public methods have @covers test coverage. Fail-closed and unrestricted-file behaviors are explicitly tested.</done>
</task>

</tasks>

<verification>
1. tests/phpunit/unit/PermissionServiceTest.php exists, extends MediaWikiUnitTestCase, correct namespace
2. PermissionService public methods covered: getLevel, setLevel, removeLevel, canUserAccessLevel, getEffectiveLevel, canUserAccessFile
3. Test count >= 25 scenarios
4. Fresh PermissionService per test (no cache poisoning)
5. Fail-closed behavior tested explicitly
6. Unrestricted file (null level) behavior tested explicitly
7. Default level fallback chain tested (explicit → namespace → global → null)
8. All globals reset in tearDown
</verification>

<success_criteria>
- PermissionServiceTest.php has 25+ test scenarios covering UNIT-04, UNIT-05, UNIT-06
- Every PermissionService public method has @covers test coverage
- All tests use mocked dependencies (no database, no real MW services)
- Fresh service instance per test (cache poisoning prevented)
- Fail-closed behavior is the most visibly tested property
- Default level fallback chain fully exercised
- Unknown/missing file handling explicitly verified
</success_criteria>

<output>
After completion, create `.planning/phases/07-test-infrastructure-unit-tests/07-02-SUMMARY.md`
</output>
