---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - includes/ServiceWiring.php
  - includes/PermissionService.php
autonomous: true

must_haves:
  truths:
    - "File permission level can be stored in PageProps"
    - "File permission level can be retrieved from PageProps"
    - "User access check respects group grants"
    - "Wildcard grant (*) gives access to all levels"
    - "Invalid config causes all access checks to deny"
  artifacts:
    - path: "includes/PermissionService.php"
      provides: "Core permission business logic"
      exports: ["getLevel", "setLevel", "canUserAccessLevel", "removeLevel"]
    - path: "includes/ServiceWiring.php"
      provides: "Service registration for dependency injection"
      contains: "FilePermissions.PermissionService"
  key_links:
    - from: "includes/ServiceWiring.php"
      to: "includes/PermissionService.php"
      via: "service instantiation"
      pattern: "new PermissionService"
    - from: "includes/PermissionService.php"
      to: "page_props table"
      via: "database query"
      pattern: "pp_propname.*fileperm_level"
    - from: "includes/PermissionService.php"
      to: "includes/Config.php"
      via: "config access"
      pattern: "Config::"
---

<objective>
Create the PermissionService class that provides the core permission logic and PageProps storage.

Purpose: This service is the API that all other phases will use to get/set file permissions and check user access. It encapsulates the storage mechanism (PageProps) and the permission check logic (group grants).

Output: Working service class registered via dependency injection that can store, retrieve, and check file permissions.
</objective>

<execution_context>
@/home/daharoni/.claude/get-shit-done/workflows/execute-plan.md
@/home/daharoni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PermissionService class</name>
  <files>includes/PermissionService.php</files>
  <action>
Create PermissionService class in FilePermissions namespace with dependency injection:

```php
namespace FilePermissions;

use MediaWiki\Title\Title;
use MediaWiki\User\UserIdentity;
use MediaWiki\User\UserGroupManager;
use Wikimedia\Rdbms\IConnectionProvider;

class PermissionService {
    private const PROP_NAME = 'fileperm_level';

    private IConnectionProvider $dbProvider;
    private UserGroupManager $userGroupManager;

    public function __construct(
        IConnectionProvider $dbProvider,
        UserGroupManager $userGroupManager
    )

    public function getLevel(Title $title): ?string
    public function setLevel(Title $title, string $level): void
    public function removeLevel(Title $title): void
    public function canUserAccessLevel(UserIdentity $user, string $level): bool
    public function canUserAccessFile(UserIdentity $user, Title $title): bool
}
```

Implementation details:

**getLevel(Title $title): ?string**
- Return null if not NS_FILE namespace
- Return null if page doesn't exist (getArticleID() === 0)
- Query page_props table for pp_propname = 'fileperm_level'
- Return the value or null if not found
- Use newSelectQueryBuilder() pattern from research

**setLevel(Title $title, string $level): void**
- Throw InvalidArgumentException if page doesn't exist
- Throw InvalidArgumentException if level is not valid (use Config::isValidLevel)
- Use newReplaceQueryBuilder() to upsert into page_props
- Fields: pp_page, pp_propname ('fileperm_level'), pp_value (level), pp_sortkey (null)

**removeLevel(Title $title): void**
- Delete from page_props where pp_page and pp_propname match
- Use newDeleteQueryBuilder()

**canUserAccessLevel(UserIdentity $user, string $level): bool**
- If Config::isInvalidConfig() returns true, return false (fail-closed)
- Get user's effective groups via userGroupManager->getUserEffectiveGroups()
- Get grants via Config::getGroupGrants()
- For each user group that has grants:
  - If grant contains '*', return true
  - If grant contains the level, return true
- Return false if no matching grant

**canUserAccessFile(UserIdentity $user, Title $title): bool**
- Get file's level via getLevel()
- If no level set, use Config::resolveDefaultLevel() with title's namespace
- If still no level (no default), treat as unrestricted (return true) - grandfathered files
- Call canUserAccessLevel() with resolved level

Use strict_types=1. Follow MediaWiki coding standards.
  </action>
  <verify>
PHP syntax valid: `php -l includes/PermissionService.php`
  </verify>
  <done>PermissionService.php exists with all methods for storing, retrieving, and checking permissions</done>
</task>

<task type="auto">
  <name>Task 2: Create ServiceWiring.php</name>
  <files>includes/ServiceWiring.php</files>
  <action>
Create ServiceWiring.php that registers PermissionService:

```php
use MediaWiki\MediaWikiServices;
use FilePermissions\PermissionService;

return [
    'FilePermissions.PermissionService' => static function (
        MediaWikiServices $services
    ): PermissionService {
        return new PermissionService(
            $services->getDBLoadBalancerFactory(),
            $services->getUserGroupManager()
        );
    },
];
```

Note: The file should NOT have a namespace declaration - it returns an array.
Use `getDBLoadBalancerFactory()` which implements IConnectionProvider.
  </action>
  <verify>
PHP syntax valid: `php -l includes/ServiceWiring.php`
Returns array: `php -r "is_array(require 'includes/ServiceWiring.php') or exit(1);"`
  </verify>
  <done>ServiceWiring.php exists and registers PermissionService with correct dependencies</done>
</task>

</tasks>

<verification>
1. All PHP files pass syntax check: `find includes -name "*.php" -exec php -l {} \;`
2. ServiceWiring returns array with 'FilePermissions.PermissionService' key
3. PermissionService has all required methods with correct signatures
</verification>

<success_criteria>
- PermissionService provides getLevel/setLevel/removeLevel for PageProps storage
- PermissionService provides canUserAccessLevel/canUserAccessFile for permission checks
- ServiceWiring correctly injects IConnectionProvider and UserGroupManager
- Fail-closed behavior implemented (returns false when config is invalid)
- Grandfathered files (no level, no default) treated as unrestricted
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
